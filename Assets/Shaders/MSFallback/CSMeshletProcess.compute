#pragma kernel ProcessMeshlets

#include "MeshletCommon.hlsl"

struct MeshOutCounts
{
    uint VertCount;
    uint PrimCount;
};

StructuredBuffer<uint> _DispatchArgs;
StructuredBuffer<uint> _VisibleMeshletIndices;

RWStructuredBuffer<VertexOut> _VertexBuffer;
RWBuffer<uint> _IndexBuffer;

// 解包三角形索引
uint3 UnpackPrimitive(uint primitive)
{
    return uint3(primitive & 0x3FF, (primitive >> 10) & 0x3FF, (primitive >> 20) & 0x3FF);
}

// 从meshlet中获取顶点索引
uint GetVertexIndex(Meshlet m, uint localIndex)
{
    localIndex = m.VertOffset + localIndex;
    return _UniqueVertexIndices.Load(localIndex * 4);
}

// 从meshlet获取三角形
uint3 GetPrimitive(Meshlet m, uint index)
{
    return UnpackPrimitive(_PrimitiveIndices[m.PrimOffset + index]);
}

// 计算并输出顶点属性
VertexOut GetVertexAttributes(uint meshletIndex, uint vertexIndex)
{
    Vertex v = _Vertices[vertexIndex];
    
    const float4 positionWS = mul(float4(v.Position, 1.0), _Instance.World);
    
    VertexOut o;
    o.PositionVS = mul(positionWS, _Constants.View).xyz;
    o.PositionHS = mul(positionWS, _Constants.ViewProj);
    o.Normal = mul(v.Normal, (float3x3)_Instance.WorldIT);
    o.MeshletIndex = meshletIndex;
    
    return o;
}

[numthreads(MS_GROUP_SIZE, 1, 1)]
void ProcessMeshlets(uint3 id : SV_DispatchThreadID, uint3 groupThreadId : SV_GroupThreadID, uint3 groupId : SV_GroupID)
{
    // 每个线程组处理一个 meshlet
    uint visibleMeshletIndex = groupId.x;
    uint localThreadId = groupThreadId.x;
    
    // 检查是否超出可见 meshlet 范围
    uint visibleCount = _DispatchArgs[1];
    if (visibleMeshletIndex >= visibleCount) return;

    // 获取实际的 meshlet 索引和 meshlet 数据
    uint globalMeshletIndex = _VisibleMeshletIndices[visibleMeshletIndex];
    Meshlet m = _Meshlets[globalMeshletIndex];

    if (localThreadId< m.VertCount) // 处理顶点 - 组内线程并行处理
    {
        uint vertexIndex = GetVertexIndex(m, localThreadId);
        
        // 计算该顶点在输出缓冲区中的位置
        uint outputIndex = MAX_VERTS_PER_MESHLET * globalMeshletIndex + localThreadId;
        
        // 写入顶点数据
        _VertexBuffer[outputIndex] = GetVertexAttributes(visibleMeshletIndex, vertexIndex);
    }

    if (localThreadId< m.PrimCount) // 处理三角形 - 组内线程并行处理
    {
        // 获取局部三角形索引
        uint3 localTri = GetPrimitive(m, localThreadId);
        
        // 计算三角形在全局索引缓冲区中的位置
        uint baseAddr = 3 * (MAX_PRIMS_PER_MESHLET * globalMeshletIndex + localThreadId);
        uint baseVtx = MAX_VERTS_PER_MESHLET * globalMeshletIndex;
        
        // 写入全局三角形索引缓冲区
        _IndexBuffer[baseAddr + 0] = baseVtx + localTri.x;
        _IndexBuffer[baseAddr + 1] = baseVtx + localTri.y;
        _IndexBuffer[baseAddr + 2] = baseVtx + localTri.z;
    }
}
