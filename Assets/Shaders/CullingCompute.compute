#pragma kernel CullingMain
#define KERNEL_SIZE_X 64
#define MESHLET_VERTEX_COUNT 64

struct BoundingSphere
{
    float3 center;
    float radius;
};

struct BoundingCone
{
    float3 normal;
    float cosAngle;
    float sinAngle;
};

struct MeshletBounds
{
    BoundingSphere boundingSphere;
    BoundingCone boundingCone;
};

struct EntityPara
{
    float4x4 model;
    uint vertexOffset;
    uint meshletIndex;
};

StructuredBuffer<EntityPara> _EntityBuffer;
StructuredBuffer<uint> _MeshletRefBuffer;
StructuredBuffer<MeshletBounds> _MeshletBoundsBuffer;

RWStructuredBuffer<uint> _VisibilityBuffer;
RWStructuredBuffer<uint> _IndirectDrawArgsBuffer;

uint _MeshletCount;

bool IsInsideFrustum()
{
    return true;
}

bool IsFacingCamera()
{
    return true;
}

bool IsMeshletVisible()
{
    return IsInsideFrustum() && IsFacingCamera();
}

[numthreads(KERNEL_SIZE_X, 1, 1)]
void CullingMain(uint3 id : SV_DispatchThreadID)
{
    uint meshletIndex = id.x;
    if (meshletIndex >= _MeshletCount) return;

    uint entityIndex = _MeshletRefBuffer[meshletIndex];
    EntityPara entity = _EntityBuffer[entityIndex];
    float4x4 model = entity.model;
    MeshletBounds bounds = _MeshletBoundsBuffer[entity.vertexOffset / MESHLET_VERTEX_COUNT + meshletIndex - entity.
        meshletIndex];

    bool isVisible = IsMeshletVisible();
    if (isVisible)
    {
        uint currenIndex = 0;
        InterlockedAdd(_IndirectDrawArgsBuffer[1], 1, currenIndex);
        _VisibilityBuffer[currenIndex] = meshletIndex;
    }
}
